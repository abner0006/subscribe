name: 'main3-1 ☞ output/source/'

# 并发配置：允许同一分支同时运行（最多2个实例），不取消正在运行的实例
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # 关键：不取消正在运行的实例，允许并发

on:
  schedule:
    - cron: '40 17 * * *'  # UTC时间
  workflow_dispatch:
    inputs:
      environment:
        description: '部署环境'
        required: true
        default: 'production'

env:
  PYTHON_VERSION: '3.10'        
  RETAIN_DAYS: 7               
  HISTORY_DIR: 'history'        
  FILES_TO_ARCHIVE: >-
    output/source/source1.txt
    output/source/source2.txt
    output/source/source3.txt
    output/source/source4.txt
    output/source/sports.html

jobs:
  run_job:
    runs-on: ubuntu-latest
    permissions:
      contents: write  
      pull-requests: write  

    steps:
      # 1. 拉取仓库代码（原版）
      - name: 拉取仓库代码
        uses: actions/checkout@v4
        with:
          ref: main

      # 2. 强制同步远程代码（原版）
      - name: 强制同步远程代码
        run: git fetch --prune && git reset --hard origin/main

      # 3. 安装Python（原版）
      - name: 安装Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # 4. 缓存依赖包（原版）
      - name: 缓存依赖包
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # 5. 安装依赖（原版）
      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install opencc-python-reimplemented pytz || { 
            echo "依赖安装失败，重试一次"; 
            pip install opencc-python-reimplemented pytz; 
          }

      # 6. 同步代码并生成文件（原版）
      - name: 同步代码并生成文件
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"
          mkdir -p output/source
          git reset --hard HEAD
          git pull origin main --rebase --autostash || { 
            echo "变基冲突，自动用远程最新代码覆盖本地";
            git rebase --abort;
            git pull origin main --force;
          }
          python main3.py || { 
            echo "首次生成失败，重试"; 
            python main3.py || { exit 1; } 
          }

      # 7. 校验文件完整性（原版）
      - name: 校验文件完整性
        run: |
          critical_files=("output/source/source1.txt" "output/source/source3.txt")
          for file in "${critical_files[@]}"; do
            if [ ! -s "$file" ]; then
              echo "错误：$file 异常，终止"; exit 1;
            fi
          done
          if ! grep -q "🌐央视频道,#genre#" "output/source/source3.txt"; then
            echo "错误：内容缺失，终止"; exit 1;
          fi

      # 8. 清理历史归档（原版）
      - name: 清理历史归档
        run: |
          mkdir -p ${{ env.HISTORY_DIR }}
          find ${{ env.HISTORY_DIR }} -name "*.zip" -type f -mtime +${{ env.RETAIN_DAYS }} -delete

      # 9. 生成今日归档（原版）
      - name: 生成今日归档
        run: |
          if git diff --quiet ${{ env.FILES_TO_ARCHIVE }}; then
            echo "文件未修改，不生成新归档";
          else
            current_datetime=$(date +"%Y%m%d_%H%M%S")
            zip_filename="${{ env.HISTORY_DIR }}/${current_datetime}_archive.zip"
            zip -j "${zip_filename}" ${{ env.FILES_TO_ARCHIVE }}
            git add "${zip_filename}"
          fi

      # 🔴 核心替换：并发兼容的暴力推送 🔴
      - name: 提交并推送更改（并发兼容，暴力覆盖）
        run: |
          # 仅提交目标文件，适配并发场景
          git add output/source/ ${{ env.HISTORY_DIR }}/
          # 提交带时间戳，区分并发实例
          git commit -m ":tada: 自动更新 $(date +'%Y%m%d_%H%M%S')" || true  
          # 强制同步远程，消除并发冲突
          git fetch origin main
          git reset --hard origin/main  
          # 暴力推送，优先 --force-with-lease，失败则 --force
          git push origin main --force-with-lease || git push origin main --force

      # 10. 保存生成的文件（原版）
      - name: 保存生成的文件
        uses: actions/upload-artifact@v4
        with:
          name: generated-files
          path: |
            output/source/source1.txt
            output/source/source1.m3u
            output/source/source2.txt
            output/source/source2.m3u
            output/source/source4.txt
            output/source/sports.html
            output/source/source3.txt
            output/source/source3.m3u
            ${{ env.HISTORY_DIR }}/*.zip
